//! This contains all of the standalone webauthn assertion
//! functionality for usage with Aptos' [`AccountAuthenticator`](https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L383)
//! for webauthn transactions.
//!
//! It uses and refactors [`authenticate_credential`](crate::WebauthnCore::authenticate_credential)
//! to statelessly support assertion verification, without the need of a
//! [`WebauthnCore`](crate::WebauthnCore) struct. We exclude many of
//! the verification steps from [`verify_credential_internal`](crate::WebauthnCore::verify_credential_internal)
//! as they are not needed.

#![warn(missing_docs)]

use crate::crypto::compute_sha256;
use crate::error::WebauthnError;
use crate::internals::*;
use crate::proto::*;
use p256::ecdsa::Signature;
use std::convert::TryFrom;

type VerificationData = Vec<u8>;
type ActualChallenge = Vec<u8>;

/// A modified version of [`verify_credential_internal`](crate::WebauthnCore::verify_credential_internal)
/// with omitted checks, not needed for [`AccountAuthenticator`](https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L383)
///
/// Some of the omitted checks include:
/// - MismatchedChallenge check
/// - AllowedOrigins check
/// - AppId extension and rpId hash check
/// - UserPresent flag
/// - UserVerified flag
/// - Credential Backed Up or Backup Eligible
/// - Authenticator Extensions check
/// - IMPORTANT: Does not verify the signature
///
/// It relies on the `AccountAuthenticator` to verify the signature
/// over the binary concatenation of
/// 1. [`authenticator_data_bytes`](crate::internals::AuthenticatorAssertionResponse) and
/// 2. [`client_data_json_hash`](crate::internals::AuthenticatorAssertionResponse),
///
/// aka `verification_data`
///
/// Returns tuple of `verification_data`, [`Signature`](p256::ecdsa::Signature), and `actual_challenge`
///
/// For more info: https://www.w3.org/TR/webauthn-3/#sctn-verifying-assertion
#[allow(dead_code)]
pub fn parse_public_key_credential(
    rsp: &PublicKeyCredential,
    cose_algorithm: COSEAlgorithm,
) -> Result<(VerificationData, Signature, ActualChallenge), WebauthnError> {
    // Parse the PublicKeyCredential response
    let data: AuthenticatorAssertionResponse<Authentication> =
        AuthenticatorAssertionResponse::try_from(&rsp.response).map_err(|e| {
            debug!("AuthenticatorAssertionResponse::try_from -> {:?}", e);
            e
        })?;
    let actual_challenge = &data.client_data.challenge.0;

    let c = &data.client_data;

    // Verify that the value of C.type is the string webauthn.get.
    if c.type_ != "webauthn.get" {
        return Err(WebauthnError::InvalidClientDataType);
    }

    // Let hash be the result of computing a hash over the cData using SHA-256.
    let client_data_json_hash = compute_sha256(data.client_data_bytes.as_slice());

    // Binary concatenation of authData and hash.
    // Note: This is compatible with signatures generated by FIDO U2F
    // authenticators. See ยง6.1.2 FIDO U2F Signature Format Compatibility
    // https://www.w3.org/TR/webauthn-2/#sctn-fido-u2f-sig-format-compat
    let verification_data: Vec<u8> = data
        .authenticator_data_bytes
        .iter()
        .chain(client_data_json_hash.iter())
        .copied()
        .collect();

    match cose_algorithm {
        COSEAlgorithm::ES256 => {
            // Convert the DER, byte encoded signature to a P256Signature that can then be used
            // to derive the raw, fixed byte length signature.
            // Uses the recommended curve -> SECP256R1
            let fixed_size_p256_signature =
                p256_der_to_fixed_size_signature(data.signature.as_slice()).map_err(|e| {
                    debug!("p256_der_to_raw_signature -> {:#?}", e);
                    WebauthnError::AttestationStatementSigInvalid
                })?;
            Ok((
                verification_data,
                fixed_size_p256_signature,
                actual_challenge.clone(),
            ))
        }
        _ => {
            debug!("Unsupported signature scheme");
            Err(WebauthnError::COSEKeyInvalidAlgorithm)
        }
    }
}

/// WebAuthn ES256 Signatures are ASN.1 DER Ecdsa-Sig-Value encoded which
/// means their byte lengths are often 70-72 bytes. This function
/// converts them into raw, fixed size signatures so they're 64 bytes
///
/// This is needed for the `AccountAuthenticator` which assumes
/// signature lengths will be 64 bytes for P256
///
/// https://www.w3.org/TR/webauthn-2/#sctn-signature-attestation-types
fn p256_der_to_fixed_size_signature(der_signature: &[u8]) -> Result<Signature, p256::ecdsa::Error> {
    let sig = Signature::from_der(der_signature).map_err(|e| {
        debug!("Signature::from_der -> {:?}", e);
        e
    })?;
    Ok(sig)
}

#[cfg(test)]
mod tests {
    #![allow(clippy::panic)]

    use crate::assertion::{p256_der_to_fixed_size_signature, parse_public_key_credential};
    use crate::internals::AuthenticatorAssertionResponse;
    use crate::proto::*;
    use crate::AttestationFormat;
    use base64urlsafedata::Base64UrlSafeData;
    use p256::ecdsa::signature::Verifier;

    // Captured authentication attempt
    static RSP: &str = r#"
        {
            "id":"at-FfKGsOI21EhtCu7Vx-7t7FKkpUOyKXIkEBBD_vC-eym_AdW6Y9V8WyKxHmii11EBQEe7uFQ0bkYwb0GWmUQ",
            "rawId":"at-FfKGsOI21EhtCu7Vx-7t7FKkpUOyKXIkEBBD_vC-eym_AdW6Y9V8WyKxHmii11EBQEe7uFQ0bkYwb0GWmUQ",
            "response":{
                "authenticatorData":"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MBAAAAFA",
                "clientDataJSON":"eyJjaGFsbGVuZ2UiOiJXZ1h6X2tUdjNXVVUxa3c4aG0tT0dvR1M0WkNIWF8zYkVxSEgyUHZWcDhNIiwiY2xpZW50RXh0ZW5zaW9ucyI6e30sImhhc2hBbGdvcml0aG0iOiJTSEEtMjU2Iiwib3JpZ2luIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwidHlwZSI6IndlYmF1dGhuLmdldCJ9",
                "signature":"MEYCIQDmLVOqv85cdRup4Fr8Pf9zC4AWO-XKBJqa8xPwYFCCMAIhAOiExLoyes0xipmUmq0BVlqJaCKLn_MFKG9GIDsCGq_-",
                "userHandle":null
            },
            "type":"public-key"
        }
        "#;

    // Helper function that creates a test P256 credential, associated with RSP above
    fn create_correct_p256_credential() -> Credential {
        Credential {
            cred_id: Base64UrlSafeData(vec![
                106, 223, 133, 124, 161, 172, 56, 141, 181, 18, 27, 66, 187, 181, 113, 251, 187,
                123, 20, 169, 41, 80, 236, 138, 92, 137, 4, 4, 16, 255, 188, 47, 158, 202, 111,
                192, 117, 110, 152, 245, 95, 22, 200, 172, 71, 154, 40, 181, 212, 64, 80, 17, 238,
                238, 21, 13, 27, 145, 140, 27, 208, 101, 166, 81,
            ]),
            cred: COSEKey {
                type_: COSEAlgorithm::ES256,
                key: COSEKeyType::EC_EC2(COSEEC2Key {
                    curve: ECDSACurve::SECP256R1,
                    x: [
                        46, 121, 76, 233, 118, 208, 250, 74, 227, 182, 8, 145, 45, 46, 5, 9, 199,
                        186, 84, 83, 7, 237, 130, 73, 16, 90, 17, 54, 33, 255, 54, 56,
                    ]
                    .to_vec()
                    .into(),
                    y: [
                        117, 105, 1, 23, 253, 223, 67, 135, 253, 219, 253, 223, 17, 247, 91, 197,
                        205, 225, 143, 59, 47, 138, 70, 120, 74, 155, 177, 177, 166, 233, 48, 71,
                    ]
                    .to_vec()
                    .into(),
                }),
            },
            counter: 1,
            transports: None,
            user_verified: false,
            backup_eligible: false,
            backup_state: false,
            registration_policy: UserVerificationPolicy::Required,
            extensions: RegisteredExtensions::none(),
            attestation: ParsedAttestation {
                data: ParsedAttestationData::None,
                metadata: AttestationMetadata::None,
            },
            attestation_format: AttestationFormat::None,
        }
    }

    // Helper function that creates an INCORRECT test P256 credential, NOT associated with RSP above
    fn create_incorrect_p256_credential() -> Credential {
        Credential {
            counter: 1,
            transports: None,
            cred_id: Base64UrlSafeData(vec![
                179, 64, 237, 0, 28, 248, 197, 30, 213, 228, 250, 139, 28, 11, 156, 130, 69, 242,
                21, 48, 84, 77, 103, 163, 66, 204, 167, 147, 82, 214, 212,
            ]),
            cred: COSEKey {
                type_: COSEAlgorithm::ES256,
                key: COSEKeyType::EC_EC2(COSEEC2Key {
                    curve: ECDSACurve::SECP256R1,
                    x: [
                        187, 71, 18, 101, 166, 110, 166, 38, 116, 119, 74, 4, 183, 104, 24, 46,
                        245, 24, 227, 143, 161, 136, 37, 186, 140, 221, 228, 115, 81, 175, 50, 51,
                    ]
                    .to_vec()
                    .into(),
                    y: [
                        13, 59, 59, 158, 149, 197, 116, 228, 99, 12, 235, 185, 190, 110, 251, 154,
                        226, 143, 75, 26, 44, 136, 244, 245, 243, 4, 40, 223, 22, 253, 224, 95,
                    ]
                    .to_vec()
                    .into(),
                }),
            },
            user_verified: false,
            backup_eligible: false,
            backup_state: false,
            registration_policy: UserVerificationPolicy::Discouraged_DO_NOT_USE,
            extensions: RegisteredExtensions::none(),
            attestation: ParsedAttestation {
                data: ParsedAttestationData::None,
                metadata: AttestationMetadata::None,
            },
            attestation_format: AttestationFormat::None,
        }
    }

    #[test]
    fn test_der_to_raw_signature() {
        // Captured authentication attempt
        let rsp_d: PublicKeyCredential = serde_json::from_str(RSP).unwrap();
        let data: AuthenticatorAssertionResponse<Authentication> =
            AuthenticatorAssertionResponse::try_from(&rsp_d.response)
                .map_err(|e| {
                    debug!("AuthenticatorAssertionResponse::try_from -> {:?}", e);
                    e
                })
                .unwrap();

        let der_sig = data.signature;
        let fixed_len_sig = p256_der_to_fixed_size_signature(&der_sig.as_slice());

        assert!(fixed_len_sig.is_ok());
        assert_eq!(fixed_len_sig.unwrap().to_bytes().to_vec().len(), 64);
    }

    #[test]
    fn test_der_to_raw_signature_failure() {
        // Captured authentication attempt
        let rsp_d: PublicKeyCredential = serde_json::from_str(RSP).unwrap();
        let data: AuthenticatorAssertionResponse<Authentication> =
            AuthenticatorAssertionResponse::try_from(&rsp_d.response)
                .map_err(|e| {
                    debug!("AuthenticatorAssertionResponse::try_from -> {:?}", e);
                    e
                })
                .unwrap();

        // add extra byte -> malformed signature
        let mut bad_der_sig = data.signature;
        bad_der_sig.push(0x1);

        let fixed_len_sig = p256_der_to_fixed_size_signature(&bad_der_sig.as_slice());
        assert!(fixed_len_sig.is_err());
    }

    #[test]
    fn test_parse_public_key_credential() {
        let _ = tracing_subscriber::fmt::try_init();

        // Create the test credential
        let cred = create_correct_p256_credential();

        let rsp_d: PublicKeyCredential = serde_json::from_str(RSP).unwrap();

        // Parse public key credential
        let r = parse_public_key_credential(&rsp_d, COSEAlgorithm::ES256);
        assert!(r.is_ok());

        // Now verify it!
        match cred.cred.key {
            COSEKeyType::EC_EC2(key) => {
                let x_bytes = &key.x.0;
                let y_bytes = &key.y.0;

                let generic_array_x =
                    generic_array::GenericArray::clone_from_slice(x_bytes.as_slice());
                let generic_array_y =
                    generic_array::GenericArray::clone_from_slice(y_bytes.as_slice());
                let encoded_point = p256::EncodedPoint::from_affine_coordinates(
                    &generic_array_x,
                    &generic_array_y,
                    false,
                );
                let verifying_key = p256::ecdsa::VerifyingKey::from_encoded_point(&encoded_point);
                assert!(verifying_key.is_ok());

                let (message_bytes, signature, ..) = r.unwrap();

                let verified = verifying_key
                    .unwrap()
                    .verify(message_bytes.as_slice(), &signature);
                assert!(verified.is_ok());
            }
            _ => {
                panic!("Test failed, credential key is not of type EC_EC2 and COSE Algorithm ES256")
            }
        }
    }

    #[test]
    fn test_parse_public_key_credential_failure() {
        let _ = tracing_subscriber::fmt::try_init();

        // Create the test credential
        let cred = create_incorrect_p256_credential();

        let rsp_d: PublicKeyCredential = serde_json::from_str(RSP).unwrap();

        // Parse public key credential
        let r = parse_public_key_credential(&rsp_d, COSEAlgorithm::ES256);
        assert!(r.is_ok());

        // Now verify it!
        match cred.cred.key {
            COSEKeyType::EC_EC2(key) => {
                let x_bytes = &key.x.0;
                let y_bytes = &key.y.0;

                let generic_array_x =
                    generic_array::GenericArray::clone_from_slice(x_bytes.as_slice());
                let generic_array_y =
                    generic_array::GenericArray::clone_from_slice(y_bytes.as_slice());
                let encoded_point = p256::EncodedPoint::from_affine_coordinates(
                    &generic_array_x,
                    &generic_array_y,
                    false,
                );
                let verifying_key = p256::ecdsa::VerifyingKey::from_encoded_point(&encoded_point);
                assert!(verifying_key.is_ok());

                let (verification_data, signature, ..) = r.unwrap();

                // Should err as verifying_key does not correspond to this signature
                let verified = verifying_key
                    .unwrap()
                    .verify(verification_data.as_slice(), &signature);

                assert!(verified.is_err());
            }
            _ => {
                panic!("Test failed, credential key is not of type EC_EC2 and COSE Algorithm ES256")
            }
        }
    }
}
